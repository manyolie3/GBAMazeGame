#include "main.h"
#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/openingscreen3.h"
#include "images/bitty2.h"
#include "images/playscreen2.h"
#include "images/brickwall.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

int checkCollision(struct Villager player, struct Platform platform) {
    // Check if the rectangles overlap
    if (player.col < platform.col + platform.width &&
        player.col + player.width > platform.col &&
        player.row < platform.row + platform.height &&
        player.row + player.height > platform.row) {
        return 1; // Collision detected
    }
    return 0; // No collision
}

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  //setPixel(HEIGHT / 2, WIDTH / 2, CYAN);

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  
  //declaring villager struct
  struct Villager villager;
  villager.row = 105;
  villager.col = 30;
  villager.width = 15;
  villager.height = 15;

  //declaring platform variables
  struct Platform platform;
  platform.row = 95;
  platform.col = 70;
  platform.width = 25;
  platform.height = 3;

  //int jumpHeight = 0;
  int jumpVelocity = -25; // Adjust as needed
  int gravity = 1; // Adjust as needed
  int jumping = 0;
  int horizontalVelocity = 0;
  int groundLevel = 100;

  //initialize timer stuff
  unsigned int timer = 30;
  int gameStart = 0;

  // Load initial application state
  enum gba_state state = START;
  drawFullScreenImageDMA(openingscreen3);
  drawCenteredString(HEIGHT / 2, WIDTH / 2, 0, 0, "HELP BITTY COLLECT LEAVES AND GET HOME!", BLACK);
  drawCenteredString(HEIGHT / 2, WIDTH / 2, 15, 15, "PRESS ENTER TO PLAY!", BLACK);


  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    if (gameStart && vBlankCounter % 60 == 0) {
      if (timer > 0) {
        timer--;
      }
    }

    waitForVBlank();
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          drawFullScreenImageDMA(playscreen2);
        }

        timer = 30;
        gameStart = 1;

        break;
      case PLAY:
        // Clear the previous position of the sprite
        drawImageDMA(platform.row, platform.col, platform.width, platform.height, brickwall);
        undrawImageDMA(villager.row, villager.col, villager.width, villager.height, playscreen2);
            
        horizontalVelocity = 0;

        // Handle horizontal movement (left/right)
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (villager.col >= 2) {
            horizontalVelocity = -1; // Adjust velocity as needed
          }
        } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
            if (villager.col <= 240 - villager.width) {
              horizontalVelocity = 1; // Adjust velocity as needed
            }
        }
            
        // Handle vertical movement (jumping)
        if (KEY_DOWN(BUTTON_UP, currentButtons) && !jumping) {
          jumping = 1; // Set jumping flag to true
          jumpVelocity = -25; // Set initial jump velocity
          } if (KEY_DOWN(BUTTON_DOWN, currentButtons) && !jumping && villager.row != groundLevel) {
            jumping = 1;
            jumpVelocity = 15;
          }
            
        // Apply gravity if not jumping or if not at the ground level
        if (!jumping || villager.row < groundLevel) {
          if (villager.row != groundLevel) {
            villager.row = groundLevel; // Apply gravity
          }
        }
            
        // Update vertical position based on jumping
        if (jumping) {
          villager.row += jumpVelocity; // Move vertically
          jumpVelocity += gravity; // Apply gravity to jump velocity
                
          // Check if the sprite reaches the ground level
          if (villager.row >= groundLevel) {
            jumping = 0; // Stop jumping
            villager.row = groundLevel; // Set sprite position to the ground level
          }
        }
            
        // Update horizontal position based on horizontal velocity
        villager.col += horizontalVelocity;

        // Check for collision with platforms
        for (int i = 0; i < 10; i++) {
          if (checkCollision(villager, platform)) {
          // Handle collision with the platform
          if (jumpVelocity > 0 && villager.row + villager.height <= platform.row) {
              // Player is jumping and hits the bottom of the platform
              villager.row = platform.row - villager.height; // Move player above the platform
              jumping = 0; // Stop jumping
            } else if (jumpVelocity <= 0 && villager.row < platform.row + platform.height && villager.row + villager.height > platform.row) {
              // Player is falling and hits the top of the platform
              villager.row = platform.row - villager.height; // Move player above the platform
            jumping = 0; // Stop jumping
          }
        }
      }
        // Draw the sprite in its new position
        drawImageDMA(villager.row, villager.col, villager.width, villager.height, bitty2);
        // state = ?

        break;
      case WIN:

        // state = ?
        break;
      case LOSE:
        fillScreenDMA(BLACK);

        // state = ?
        break;
    }

     if (state == PLAY) {
      drawImageDMA(5, 5, 60, 20, playscreen2);
      char timerStr[10];
      snprintf(timerStr, sizeof(timerStr), "T: %d", timer);
      drawString(5, 5 , timerStr, BLACK);
     }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
