#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/openingscreen3.h"
#include "images/bitty2.h"
#include "images/playscreen2.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  //setPixel(HEIGHT / 2, WIDTH / 2, CYAN);

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  
  //declaring villager struct
  struct Villager villager;
  villager.row = 105;
  villager.col = 30;
  villager.width = 25;
  villager.height = 25;

  //declaring platform variables
  struct Platform platform;
  platform.row = 50;
  platform.col = 40;
  platform.width = 20;
  platform.height = 10;

  //int jumpHeight = 0;
  int jumpVelocity = -25; // Adjust as needed
  int gravity = 1; // Adjust as needed
  int jumping = 0;
  int horizontalVelocity = 0;
  int groundLevel = 100;

  // Load initial application state
  enum gba_state state = START;
  drawFullScreenImageDMA(openingscreen3);
  drawCenteredString(HEIGHT / 2, WIDTH / 2, 0, 0, "WELCOME, PRESS ENTER TO PLAY", BLACK);


  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    waitForVBlank();
    
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          drawFullScreenImageDMA(playscreen2);
        }
        break;
      case PLAY:
        // Clear the previous position of the sprite
            drawRectDMA(platform.row, platform.col, platform.width, platform.height, BLACK);  
            undrawImageDMA(villager.row, villager.col, villager.width, villager.height, playscreen2);
            
            horizontalVelocity = 0;

            // Handle horizontal movement (left/right)
            if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
                if (villager.col >= 2) {
                  horizontalVelocity = -2; // Adjust velocity as needed
                }
            } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
                if (villager.col <= 240 - villager.width) {
                  horizontalVelocity = 2; // Adjust velocity as needed
                }
            }
            
            // Handle vertical movement (jumping)
            if (KEY_DOWN(BUTTON_UP, currentButtons) && !jumping) {
                jumping = 1; // Set jumping flag to true
                jumpVelocity = -25; // Set initial jump velocity
            } if (KEY_DOWN(BUTTON_DOWN, currentButtons) && !jumping && villager.row != groundLevel) {
                jumping = 1;
                jumpVelocity = 15;
            }
            
            // Apply gravity if not jumping or if not at the ground level
            if (!jumping || villager.row < groundLevel) {
                if (villager.row != groundLevel) {
                  villager.row = groundLevel; // Apply gravity
                }
            }
            
            // Update vertical position based on jumping
            if (jumping) {
                villager.row += jumpVelocity; // Move vertically
                jumpVelocity += gravity; // Apply gravity to jump velocity
                
                // Check if the sprite reaches the ground level
                if (villager.row >= groundLevel) {
                    jumping = 0; // Stop jumping
                    villager.row = groundLevel; // Set sprite position to the ground level
                }
            }
            
            // Update horizontal position based on horizontal velocity
            villager.col += horizontalVelocity;
            
            // Draw the sprite in its new position
            drawImageDMA(villager.row, villager.col, villager.width, villager.height, bitty2);
            // state = ?
        break;
      case WIN:

        // state = ?
        break;
      case LOSE:

        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
